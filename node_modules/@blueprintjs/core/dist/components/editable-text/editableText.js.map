{"version":3,"sources":["../src/components/editable-text/editableText.tsx"],"names":[],"mappings":"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","file":"editableText.js","sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\nimport * as classNames from \"classnames\";\nimport * as PureRender from \"pure-render-decorator\";\nimport * as React from \"react\";\n\nimport { AbstractComponent } from \"../../common/abstractComponent\";\nimport * as Classes from \"../../common/classes\";\nimport * as Keys from \"../../common/keys\";\nimport { IIntentProps, IProps } from \"../../common/props\";\nimport { clamp, safeInvoke } from \"../../common/utils\";\nimport { Browser } from \"../../compatibility\";\n\nexport interface IEditableTextProps extends IIntentProps, IProps {\n    /**\n     * If `true` and in multiline mode, the `enter` key will trigger onConfirm and `mod+enter`\n     * will insert a newline. If `false`, the key bindings are inverted such that `enter`\n     * adds a newline.\n     * @default false\n     */\n    confirmOnEnterKey?: boolean;\n\n    /** Default text value of uncontrolled input. */\n    defaultValue?: string;\n\n    /**\n     * Whether the text can be edited.\n     * @default false\n     */\n    disabled?: boolean;\n\n    /** Whether the component is currently being edited. */\n    isEditing?: boolean;\n\n    /** Maximum number of characters allowed. Unlimited by default. */\n    maxLength?: number;\n\n    /** Minimum width in pixels of the input, when not `multiline`. */\n    minWidth?: number;\n\n    /**\n     * Whether the component supports multiple lines of text.\n     * This prop should not be changed during the component's lifetime.\n     * @default false\n     */\n    multiline?: boolean;\n\n    /**\n     * Maximum number of lines before scrolling begins, when `multiline`.\n     */\n    maxLines?: number;\n\n    /**\n     * Minimum number of lines (essentially minimum height), when `multiline`.\n     * @default 1\n     */\n    minLines?: number;\n\n    /**\n     * Placeholder text when there is no value.\n     * @default \"Click to Edit\"\n     */\n    placeholder?: string;\n\n    /**\n     * Whether the entire text field should be selected on focus.\n     * If `false`, the cursor is placed at the end of the text.\n     * @default false\n     */\n    selectAllOnFocus?: boolean;\n\n    /** Text value of controlled input. */\n    value?: string;\n\n    /** Callback invoked when user cancels input with the `esc` key. Receives last confirmed value. */\n    onCancel?(value: string): void;\n\n    /** Callback invoked when user changes input in any way. */\n    onChange?(value: string): void;\n\n    /** Callback invoked when user confirms value with `enter` key or by blurring input. */\n    onConfirm?(value: string): void;\n\n    /** Callback invoked after the user enters edit mode. */\n    onEdit?(): void;\n}\n\nexport interface IEditableTextState {\n    /** Pixel height of the input, measured from span size */\n    inputHeight?: number;\n    /** Pixel width of the input, measured from span size */\n    inputWidth?: number;\n    /** Whether the value is currently being edited */\n    isEditing?: boolean;\n    /** The last confirmed value */\n    lastValue?: string;\n    /** The controlled input value, may be different from prop during editing */\n    value?: string;\n}\n\nconst BUFFER_WIDTH_EDGE = 5;\nconst BUFFER_WIDTH_IE = 30;\n\n@PureRender\nexport class EditableText extends AbstractComponent<IEditableTextProps, IEditableTextState> {\n    public static defaultProps: IEditableTextProps = {\n        confirmOnEnterKey: false,\n        defaultValue: \"\",\n        disabled: false,\n        maxLines: Infinity,\n        minLines: 1,\n        minWidth: 80,\n        multiline: false,\n        placeholder: \"Click to Edit\",\n    };\n\n    private valueElement: HTMLSpanElement;\n    private refHandlers = {\n        content: (spanElement: HTMLSpanElement) => {\n            this.valueElement = spanElement;\n        },\n        input: (input: HTMLInputElement | HTMLTextAreaElement) => {\n            if (input != null) {\n                input.focus();\n                const { length } = input.value;\n                input.setSelectionRange(this.props.selectAllOnFocus ? 0 : length, length);\n            }\n        },\n    };\n\n    public constructor(props?: IEditableTextProps, context?: any) {\n        super(props, context);\n\n        const value = props.value == null ? props.defaultValue : props.value;\n        this.state = {\n            inputHeight: 0,\n            inputWidth: 0,\n            isEditing: props.isEditing === true && props.disabled === false,\n            lastValue: value,\n            value,\n        };\n    }\n\n    public render() {\n        const { disabled, multiline } = this.props;\n        const value = this.props.value == null ? this.state.value : this.props.value;\n        const hasValue = value != null && value !== \"\";\n\n        const classes = classNames(\n            Classes.EDITABLE_TEXT,\n            Classes.intentClass(this.props.intent),\n            {\n                [Classes.DISABLED]: disabled,\n                \"pt-editable-editing\": this.state.isEditing,\n                \"pt-editable-placeholder\": !hasValue,\n                \"pt-multiline\": multiline,\n            },\n            this.props.className,\n        );\n\n        let contentStyle: React.CSSProperties;\n        if (multiline) {\n            // set height only in multiline mode when not editing\n            // otherwise we're measuring this element to determine appropriate height of text\n            contentStyle = { height: !this.state.isEditing ? this.state.inputHeight : null };\n        } else {\n            // minWidth only applies in single line mode (multiline == width 100%)\n            contentStyle = {\n                height: this.state.inputHeight,\n                lineHeight: this.state.inputHeight != null ? `${this.state.inputHeight}px` : null,\n                minWidth: this.props.minWidth,\n            };\n        }\n\n        // make enclosing div focusable when not editing, so it can still be tabbed to focus\n        // (when editing, input itself is focusable so div doesn't need to be)\n        const tabIndex = this.state.isEditing || disabled ? null : 0;\n        return (\n            <div className={classes} onFocus={this.handleFocus} tabIndex={tabIndex}>\n                {this.maybeRenderInput(value)}\n                <span className=\"pt-editable-content\" ref={this.refHandlers.content} style={contentStyle}>\n                    {hasValue ? value : this.props.placeholder}\n                </span>\n            </div>\n        );\n    }\n\n    public componentDidMount() {\n        this.updateInputDimensions();\n    }\n\n    public componentDidUpdate(_: IEditableTextProps, prevState: IEditableTextState) {\n        if (this.state.isEditing && !prevState.isEditing) {\n            safeInvoke(this.props.onEdit);\n        }\n        this.updateInputDimensions();\n    }\n\n    public componentWillReceiveProps(nextProps: IEditableTextProps) {\n        const state: IEditableTextState = {};\n        if (nextProps.value != null) {\n            state.value = nextProps.value;\n        }\n        if (nextProps.isEditing != null) {\n            state.isEditing = nextProps.isEditing;\n        }\n        if (nextProps.disabled || (nextProps.disabled == null && this.props.disabled)) {\n            state.isEditing = false;\n        }\n        this.setState(state);\n    }\n\n    public cancelEditing = () => {\n        const { lastValue, value } = this.state;\n        this.setState({ isEditing: false, value: lastValue });\n        if (value !== lastValue) {\n            safeInvoke(this.props.onChange, lastValue);\n        }\n        safeInvoke(this.props.onCancel, lastValue);\n    };\n\n    public toggleEditing = () => {\n        if (this.state.isEditing) {\n            const { value } = this.state;\n            this.setState({ isEditing: false, lastValue: value });\n            safeInvoke(this.props.onConfirm, value);\n        } else if (!this.props.disabled) {\n            this.setState({ isEditing: true });\n        }\n    };\n\n    private handleFocus = () => {\n        if (!this.props.disabled) {\n            this.setState({ isEditing: true });\n        }\n    };\n\n    private handleTextChange = (event: React.FormEvent<HTMLElement>) => {\n        const value = (event.target as HTMLInputElement).value;\n        // state value should be updated only when uncontrolled\n        if (this.props.value == null) {\n            this.setState({ value });\n        }\n        safeInvoke(this.props.onChange, value);\n    };\n\n    private handleKeyEvent = (event: React.KeyboardEvent<HTMLElement>) => {\n        const { altKey, ctrlKey, metaKey, shiftKey, which } = event;\n        if (which === Keys.ESCAPE) {\n            this.cancelEditing();\n            return;\n        }\n\n        const hasModifierKey = altKey || ctrlKey || metaKey || shiftKey;\n        if (which === Keys.ENTER) {\n            // prevent IE11 from full screening with alt + enter\n            // shift + enter adds a newline by default\n            if (altKey || shiftKey) {\n                event.preventDefault();\n            }\n\n            if (this.props.confirmOnEnterKey && this.props.multiline) {\n                if (event.target != null && hasModifierKey) {\n                    insertAtCaret(event.target as HTMLTextAreaElement, \"\\n\");\n                    this.handleTextChange(event);\n                } else {\n                    this.toggleEditing();\n                }\n            } else if (!this.props.multiline || hasModifierKey) {\n                this.toggleEditing();\n            }\n        }\n    };\n\n    private maybeRenderInput(value: string) {\n        const { maxLength, multiline } = this.props;\n        if (!this.state.isEditing) {\n            return undefined;\n        }\n        const props: React.HTMLProps<HTMLInputElement | HTMLTextAreaElement> = {\n            className: \"pt-editable-input\",\n            maxLength,\n            onBlur: this.toggleEditing,\n            onChange: this.handleTextChange,\n            onKeyDown: this.handleKeyEvent,\n            ref: this.refHandlers.input,\n            style: {\n                height: this.state.inputHeight,\n                lineHeight: !multiline && this.state.inputHeight != null ? `${this.state.inputHeight}px` : null,\n                width: multiline ? \"100%\" : this.state.inputWidth,\n            },\n            value,\n        };\n        return multiline ? <textarea {...props} /> : <input type=\"text\" {...props} />;\n    }\n\n    private updateInputDimensions() {\n        if (this.valueElement != null) {\n            const { maxLines, minLines, minWidth, multiline } = this.props;\n            const { parentElement, textContent } = this.valueElement;\n            let { scrollHeight, scrollWidth } = this.valueElement;\n            const lineHeight = getLineHeight(this.valueElement);\n            // add one line to computed <span> height if text ends in newline\n            // because <span> collapses that trailing whitespace but <textarea> shows it\n            if (multiline && this.state.isEditing && /\\n$/.test(textContent)) {\n                scrollHeight += lineHeight;\n            }\n            if (lineHeight > 0) {\n                // line height could be 0 if the isNaN block from getLineHeight kicks in\n                scrollHeight = clamp(scrollHeight, minLines * lineHeight, maxLines * lineHeight);\n            }\n            // Chrome's input caret height misaligns text so the line-height must be larger than font-size.\n            // The computed scrollHeight must also account for a larger inherited line-height from the parent.\n            scrollHeight = Math.max(scrollHeight, getFontSize(this.valueElement) + 1, getLineHeight(parentElement));\n            // IE11 & Edge needs a small buffer so text does not shift prior to resizing\n            if (Browser.isEdge()) {\n                scrollWidth += BUFFER_WIDTH_EDGE;\n            } else if (Browser.isInternetExplorer()) {\n                scrollWidth += BUFFER_WIDTH_IE;\n            }\n            this.setState({\n                inputHeight: scrollHeight,\n                inputWidth: Math.max(scrollWidth, minWidth),\n            });\n            // synchronizes the ::before pseudo-element's height while editing for Chrome 53\n            if (multiline && this.state.isEditing) {\n                this.setTimeout(() => (parentElement.style.height = `${scrollHeight}px`));\n            }\n        }\n    }\n}\n\nfunction getFontSize(element: HTMLElement) {\n    const fontSize = getComputedStyle(element).fontSize;\n    return fontSize === \"\" ? 0 : parseInt(fontSize.slice(0, -2), 10);\n}\n\nfunction getLineHeight(element: HTMLElement) {\n    // getComputedStyle() => 18.0001px => 18\n    let lineHeight = parseInt(getComputedStyle(element).lineHeight.slice(0, -2), 10);\n    // this check will be true if line-height is a keyword like \"normal\"\n    if (isNaN(lineHeight)) {\n        // @see http://stackoverflow.com/a/18430767/6342931\n        const line = document.createElement(\"span\");\n        line.innerHTML = \"<br>\";\n        element.appendChild(line);\n        const singleLineHeight = element.offsetHeight;\n        line.innerHTML = \"<br><br>\";\n        const doubleLineHeight = element.offsetHeight;\n        element.removeChild(line);\n        // this can return 0 in edge cases\n        lineHeight = doubleLineHeight - singleLineHeight;\n    }\n    return lineHeight;\n}\n\nfunction insertAtCaret(el: HTMLTextAreaElement, text: string) {\n    const { selectionEnd, selectionStart, value } = el;\n    if (selectionStart >= 0) {\n        const before = value.substring(0, selectionStart);\n        const after = value.substring(selectionEnd, value.length);\n        const len = text.length;\n        el.value = `${before}${text}${after}`;\n        el.selectionStart = selectionStart + len;\n        el.selectionEnd = selectionStart + len;\n    }\n}\n\nexport const EditableTextFactory = React.createFactory(EditableText);\n"]}